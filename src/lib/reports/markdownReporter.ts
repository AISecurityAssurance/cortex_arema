import { AnalysisSession, SecurityFinding, FindingValidation } from "@/types";
import { ValidationStorage } from "../storage/validationStorage";

export class MarkdownReporter {
  /**
   * Generate a comprehensive security analysis report
   */
  static generateSecurityReport(session: AnalysisSession): string {
    const report: string[] = [];

    // Header
    report.push(`# Security Analysis Report: ${session.name}`);
    report.push("");
    report.push(`**Generated:** ${new Date().toLocaleString()}`);
    report.push(
      `**Analysis Type:** ${
        session.promptTemplate?.analysisType
          ? session.promptTemplate.analysisType.toUpperCase()
          : "N/A"
      }`
    );
    report.push(`**Session ID:** ${session.id}`);
    report.push("");

    // Executive Summary
    report.push("## Executive Summary");
    report.push("");
    report.push(this.generateExecutiveSummary(session));
    report.push("");

    // Progress Overview
    report.push("## Analysis Progress");
    report.push("");
    report.push(this.generateProgressOverview(session));
    report.push("");

    // Findings by Severity
    report.push("## Findings by Severity");
    report.push("");

    const allFindings = [...session.modelAResults, ...session.modelBResults];
    const findingsBySeverity = this.groupFindingsBySeverity(allFindings);

    ["high", "medium", "low"].forEach((severity) => {
      const findings = findingsBySeverity[severity] || [];
      if (findings.length > 0) {
        report.push(
          `### ${
            severity.charAt(0).toUpperCase() + severity.slice(1)
          } Severity (${findings.length})`
        );
        report.push("");

        findings.forEach((finding, index) => {
          const validation = session.validations.find(
            (v) => v.findingId === finding.id
          );
          report.push(
            this.generateFindingSection(finding, validation, index + 1)
          );
          report.push("");
        });
      }
    });

    // Model Comparison
    report.push("## Model Performance Comparison");
    report.push("");
    report.push(this.generateModelComparison(session));
    report.push("");

    // Validation Statistics
    if (session.validations.length > 0) {
      report.push("## Validation Statistics");
      report.push("");
      report.push(this.generateValidationStats(session));
      report.push("");
    }

    // Recommendations
    report.push("## Recommendations");
    report.push("");
    report.push(this.generateRecommendations(session));
    report.push("");

    // Footer
    report.push("---");
    report.push("");
    report.push(
      "*This report was generated by Cortex Arena Security Sandbox Analysis Platform*"
    );

    return report.join("\n");
  }

  /**
   * Generate executive summary
   */
  private static generateExecutiveSummary(session: AnalysisSession): string {
    const summary: string[] = [];
    const allFindings = [...session.modelAResults, ...session.modelBResults];
    const uniqueFindings = this.deduplicateFindings(allFindings);

    const highSeverity = uniqueFindings.filter(
      (f) => f.severity === "high"
    ).length;
    const mediumSeverity = uniqueFindings.filter(
      (f) => f.severity === "medium"
    ).length;
    const lowSeverity = uniqueFindings.filter(
      (f) => f.severity === "low"
    ).length;

    const confirmedFindings = session.validations.filter(
      (v) => v.status === "confirmed"
    ).length;
    const falsePositives = session.validations.filter(
      (v) => v.status === "false-positive"
    ).length;

    summary.push(
      `The security analysis identified **${uniqueFindings.length} unique security findings** across the analyzed system:`
    );
    summary.push("");
    summary.push(
      `- **${highSeverity}** High severity issues requiring immediate attention`
    );
    summary.push(
      `- **${mediumSeverity}** Medium severity issues to be addressed`
    );
    summary.push(`- **${lowSeverity}** Low severity issues for consideration`);
    summary.push("");

    if (session.validations.length > 0) {
      summary.push(`Validation results:`);
      summary.push(`- **${confirmedFindings}** findings confirmed as valid`);
      summary.push(`- **${falsePositives}** identified as false positives`);
      summary.push(
        `- **${
          session.progress.validatedFindings -
          confirmedFindings -
          falsePositives
        }** require further review`
      );
    }

    return summary.join("\n");
  }

  /**
   * Generate progress overview
   */
  private static generateProgressOverview(session: AnalysisSession): string {
    const progress: string[] = [];
    const percentage =
      session.progress.totalFindings > 0
        ? Math.round(
            (session.progress.validatedFindings /
              session.progress.totalFindings) *
              100
          )
        : 0;

    progress.push("| Metric | Value |");
    progress.push("|--------|-------|");
    progress.push(`| Total Findings | ${session.progress.totalFindings} |`);
    progress.push(
      `| Validated | ${session.progress.validatedFindings} (${percentage}%) |`
    );
    progress.push(`| Confirmed | ${session.progress.confirmedFindings} |`);
    progress.push(`| False Positives | ${session.progress.falsePositives} |`);
    progress.push(
      `| Pending Review | ${
        session.progress.totalFindings - session.progress.validatedFindings
      } |`
    );

    return progress.join("\n");
  }

  /**
   * Generate finding section
   */
  private static generateFindingSection(
    finding: SecurityFinding,
    validation?: FindingValidation,
    number?: number
  ): string {
    const section: string[] = [];

    section.push(`#### ${number ? `${number}. ` : ""}${finding.title}`);
    section.push("");

    // Metadata
    const metadata: string[] = [];
    metadata.push(`**Severity:** ${finding.severity.toUpperCase()}`);
    metadata.push(`**Category:** ${finding.category}`);
    if (finding.cweId) metadata.push(`**CWE:** CWE-${finding.cweId}`);
    if (finding.confidence)
      metadata.push(`**Confidence:** ${finding.confidence}%`);
    metadata.push(`**Source:** ${finding.modelSource}`);

    if (validation) {
      metadata.push(
        `**Status:** ${this.formatValidationStatus(validation.status)}`
      );
    }

    section.push(metadata.join(" | "));
    section.push("");

    // Description
    section.push("**Description:**");
    section.push(finding.description);
    section.push("");

    // Mitigations
    if (finding.mitigations && finding.mitigations.length > 0) {
      section.push("**Recommended Mitigations:**");
      finding.mitigations.forEach((mitigation) => {
        section.push(`- ${mitigation}`);
      });
      section.push("");
    }

    // Validation details
    if (validation && validation.status !== "pending") {
      section.push("**Validation Details:**");
      section.push(`- Accuracy: ${validation.accuracy}/5`);
      section.push(`- Completeness: ${validation.completeness}/5`);
      section.push(`- Relevance: ${validation.relevance}/5`);
      section.push(`- Actionability: ${validation.actionability}/5`);

      if (validation.notes) {
        section.push("");
        section.push("**Validator Notes:**");
        section.push(`> ${validation.notes.replace(/\n/g, "\n> ")}`);
      }
    }

    return section.join("\n");
  }

  /**
   * Generate model comparison
   */
  private static generateModelComparison(session: AnalysisSession): string {
    const comparison: string[] = [];

    comparison.push(
      "| Model | Total Findings | High | Medium | Low | Avg Confidence |"
    );
    comparison.push(
      "|-------|----------------|------|--------|-----|----------------|"
    );

    const modelAStats = this.calculateModelStats(session.modelAResults);
    const modelBStats = this.calculateModelStats(session.modelBResults);

    comparison.push(
      `| ${session.modelAId || "Model A"} | ${modelAStats.total} | ${
        modelAStats.high
      } | ${modelAStats.medium} | ${modelAStats.low} | ${
        modelAStats.avgConfidence
      }% |`
    );
    comparison.push(
      `| ${session.modelBId || "Model B"} | ${modelBStats.total} | ${
        modelBStats.high
      } | ${modelBStats.medium} | ${modelBStats.low} | ${
        modelBStats.avgConfidence
      }% |`
    );

    return comparison.join("\n");
  }

  /**
   * Generate validation statistics
   */
  private static generateValidationStats(session: AnalysisSession): string {
    const stats: string[] = [];
    const validationStats = ValidationStorage.getValidationStats(session.id);

    stats.push("### Overall Quality Scores (1-5 scale)");
    stats.push("");
    stats.push("| Dimension | Average Score |");
    stats.push("|-----------|---------------|");
    stats.push(
      `| Accuracy | ${validationStats.averageScores.accuracy.toFixed(1)} |`
    );
    stats.push(
      `| Completeness | ${validationStats.averageScores.completeness.toFixed(
        1
      )} |`
    );
    stats.push(
      `| Relevance | ${validationStats.averageScores.relevance.toFixed(1)} |`
    );
    stats.push(
      `| Actionability | ${validationStats.averageScores.actionability.toFixed(
        1
      )} |`
    );

    return stats.join("\n");
  }

  /**
   * Generate recommendations
   */
  private static generateRecommendations(session: AnalysisSession): string {
    const recommendations: string[] = [];
    const confirmedFindings = session.validations.filter(
      (v) => v.status === "confirmed"
    );
    const highSeverityConfirmed = confirmedFindings.filter((v) => {
      const finding = [...session.modelAResults, ...session.modelBResults].find(
        (f) => f.id === v.findingId
      );
      return finding?.severity === "high";
    });

    recommendations.push("Based on the analysis results, we recommend:");
    recommendations.push("");

    if (highSeverityConfirmed.length > 0) {
      recommendations.push(
        `1. **Immediate Action Required:** Address ${highSeverityConfirmed.length} confirmed high-severity vulnerabilities`
      );
    }

    recommendations.push(
      "2. **Prioritize Remediation:** Focus on confirmed findings with high actionability scores"
    );
    recommendations.push(
      "3. **Continuous Monitoring:** Implement monitoring for the identified attack vectors"
    );
    recommendations.push(
      "4. **Regular Assessment:** Schedule follow-up analysis after implementing mitigations"
    );

    if (session.progress.validatedFindings < session.progress.totalFindings) {
      recommendations.push(
        `5. **Complete Validation:** ${
          session.progress.totalFindings - session.progress.validatedFindings
        } findings still require validation`
      );
    }

    return recommendations.join("\n");
  }

  /**
   * Helper methods
   */
  private static groupFindingsBySeverity(
    findings: SecurityFinding[]
  ): Record<string, SecurityFinding[]> {
    return findings.reduce((acc, finding) => {
      if (!acc[finding.severity]) acc[finding.severity] = [];
      acc[finding.severity].push(finding);
      return acc;
    }, {} as Record<string, SecurityFinding[]>);
  }

  private static deduplicateFindings(
    findings: SecurityFinding[]
  ): SecurityFinding[] {
    const seen = new Set<string>();
    return findings.filter((finding) => {
      const key = `${finding.title}-${finding.severity}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }

  private static calculateModelStats(findings: SecurityFinding[]) {
    const stats = {
      total: findings.length,
      high: findings.filter((f) => f.severity === "high").length,
      medium: findings.filter((f) => f.severity === "medium").length,
      low: findings.filter((f) => f.severity === "low").length,
      avgConfidence: 0,
    };

    const withConfidence = findings.filter((f) => f.confidence !== undefined);
    if (withConfidence.length > 0) {
      stats.avgConfidence = Math.round(
        withConfidence.reduce((sum, f) => sum + (f.confidence || 0), 0) /
          withConfidence.length
      );
    }

    return stats;
  }

  private static formatValidationStatus(status: string): string {
    switch (status) {
      case "confirmed":
        return "✅ Confirmed";
      case "false-positive":
        return "❌ False Positive";
      case "needs-review":
        return "⚠️ Needs Review";
      default:
        return "⏳ Pending";
    }
  }

  /**
   * Generate a model performance comparison report
   */
  static generateModelPerformanceReport(sessions: AnalysisSession[]): string {
    const report: string[] = [];

    report.push("# Model Performance Report");
    report.push("");
    report.push(`**Generated:** ${new Date().toLocaleString()}`);
    report.push(`**Sessions Analyzed:** ${sessions.length}`);
    report.push("");

    // Aggregate model performance
    const modelPerformance = new Map<
      string,
      {
        totalFindings: number;
        confirmedFindings: number;
        falsePositives: number;
        sessions: number;
      }
    >();

    sessions.forEach((session) => {
      // Model A
      if (session.modelAId) {
        const perf = modelPerformance.get(session.modelAId) || {
          totalFindings: 0,
          confirmedFindings: 0,
          falsePositives: 0,
          sessions: 0,
        };

        perf.totalFindings += session.modelAResults.length;
        perf.sessions += 1;

        session.modelAResults.forEach((finding) => {
          const validation = session.validations.find(
            (v) => v.findingId === finding.id
          );
          if (validation?.status === "confirmed") perf.confirmedFindings++;
          if (validation?.status === "false-positive") perf.falsePositives++;
        });

        modelPerformance.set(session.modelAId, perf);
      }

      // Model B
      if (session.modelBId) {
        const perf = modelPerformance.get(session.modelBId) || {
          totalFindings: 0,
          confirmedFindings: 0,
          falsePositives: 0,
          sessions: 0,
        };

        perf.totalFindings += session.modelBResults.length;
        perf.sessions += 1;

        session.modelBResults.forEach((finding) => {
          const validation = session.validations.find(
            (v) => v.findingId === finding.id
          );
          if (validation?.status === "confirmed") perf.confirmedFindings++;
          if (validation?.status === "false-positive") perf.falsePositives++;
        });

        modelPerformance.set(session.modelBId, perf);
      }
    });

    report.push("## Model Performance Summary");
    report.push("");
    report.push(
      "| Model | Sessions | Total Findings | Confirmed | False Positives | Precision |"
    );
    report.push(
      "|-------|----------|----------------|-----------|-----------------|-----------|"
    );

    modelPerformance.forEach((perf, modelId) => {
      const precision =
        perf.totalFindings > 0
          ? Math.round(
              (perf.confirmedFindings /
                (perf.confirmedFindings + perf.falsePositives)) *
                100
            ) || 0
          : 0;

      report.push(
        `| ${modelId} | ${perf.sessions} | ${perf.totalFindings} | ${perf.confirmedFindings} | ${perf.falsePositives} | ${precision}% |`
      );
    });

    return report.join("\n");
  }
}
